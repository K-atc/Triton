const char script[] = ""
	"#!/usr/bin/python2\n"
	"import pyvex\n"
	"import archinfo\n"
	"from capstone import *\n"
	"import sys\n"
	"from hexdump import hexdump\n"
	"\n"
	"class UnhandledStmtError(Exception):\n"
	"    def __init__(self, x):\n"
	"        self.expression = x.pp()\n"
	"        self.message = \"Unhandled Statement Error\"\n"
	"\n"
	"def usage():\n"
	"    print(\"{} BIN_FILE\".format(sys.argv[0]))\n"
	"    exit(1)\n"
	"\n"
	"def clean_dir(x):\n"
	"    print(filter(lambda x: not x.startswith('_'), dir(x)))\n"
	"\n"
	"def parse_expr_args(args):\n"
	"    ret = []\n"
	"    for i, x in enumerate(args):\n"
	"        ret.append({})\n"
	"        ret[i]['tag'] = x.tag\n"
	"        if x.tag in [\"Iex_RdTmp\"]:\n"
	"            ret[i]['tmp'] = x.tmp\n"
	"        elif x.tag in [\"Iex_Const\"]:\n"
	"            ret[i]['con'] = int(str(x.con), 16)\n"
	"        else:\n"
	"            raise UnhandledStmtError(expr)\n"
	"    return ret\n"
	"\n"
	"def parse_expr(expr):\n"
	"    ret = {}\n"
	"    ret['tag'] = expr.tag\n"
	"    if expr.tag in [\"Iex_Get\"]:\n"
	"        clean_dir(expr)\n"
	"        ret['offset'] = expr.offset\n"
	"        ret['ty'] = expr.ty\n"
	"    elif expr.tag in [\"Iex_Const\"]:\n"
	"        ret['con'] = int(str(expr.con), 16)\n"
	"    elif expr.tag in [\"Iex_RdTmp\"]:\n"
	"        ret['tmp'] = expr.tmp\n"
	"    elif expr.tag in [\"Iex_Binop\", \"Iex_Unop\"]:\n"
	"        ret['op'] = expr.op\n"
	"        ret['args'] = parse_expr_args(expr.args)\n"
	"    elif expr.tag in [\"Iex_Load\"]:\n"
	"        ret['addr'] = parse_expr(expr.addr)\n"
	"        ret['ty'] = expr.ty\n"
	"    elif expr.tag in [\"Iex_CCall\"]:\n"
	"        ret['retty'] = expr.retty\n"
	"        ret['cee'] = expr.cee\n"
	"        ret['args'] = parse_expr_args(expr.args)\n"
	"    else:\n"
	"        raise UnhandledStmtError(expr)\n"
	"    return ret\n"
	"\n"
	"def Lift(insn_bytes, START_ADDR, count):\n"
	"    md = Cs(CS_ARCH_X86, CS_MODE_64)\n"
	"    # for i in md.disasm(insn_bytes, 0x1000):\n"
	"    #     print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\n"
	"    #     print(\"%r\" % i.bytes)\n"
	"    #     irsb = pyvex.IRSB(bytes(i.bytes), START_ADDR, archinfo.ArchAMD64(), max_bytes=len(i.bytes))\n"
	"    #     irsb.pp()\n"
	"\n"
	"    offset = 0\n"
	"    len_insn_bytes = len(insn_bytes)\n"
	"    if count < len_insn_bytes:\n"
	"        len_insn_bytes = count\n"
	"        insn_bytes = insn_bytes[:len_insn_bytes]\n"
	"    insns = []\n"
	"    while offset < len_insn_bytes:\n"
	"        ### print a instruction\n"
	"        print(\"\")\n"
	"        for insn in md.disasm(insn_bytes[offset:], START_ADDR + offset):\n"
	"            print(\"0x%x:\\t%s\\t%s\" %(insn.address, insn.mnemonic, insn.op_str))\n"
	"            # irsb = pyvex.IRSB(bytes(insn.bytes), insn.address, archinfo.ArchAMD64(), max_bytes=insn.size)\n"
	"            break\n"
	"        if True:\n"
	"            try:\n"
	"                irsb = pyvex.IRSB(insn_bytes[offset:], insn.address, archinfo.ArchAMD64())\n"
	"            except Exception as e:\n"
	"                print(\"[!] Exception: \" + str(e))\n"
	"                break # quit lifting\n"
	"            offset += irsb.size\n"
	"            # continue\n"
	"            \n"
	"            ### pretty print a basic block\n"
	"            irsb.pp()\n"
	"\n"
	"            ### interpret statements\n"
	"            for stmt in irsb.statements:\n"
	"                ### Skip lifting\n"
	"                if stmt.tag in [\"Ist_Put\", \"Ist_IMark\"]:\n"
	"                    # continue\n"
	"                    pass\n"
	"                \n"
	"                # clean_dir(stmt)\n"
	"                print(\"\")\n"
	"                stmt.pp()\n"
	"\n"
	"                ret = {}\n"
	"                ret['full'] = str(stmt)\n"
	"                ret['tag'] = stmt.tag\n"
	"                if False:\n"
	"                    pass\n"
	"                elif stmt.tag in [\"Ist_Put\"]:\n"
	"                    ret['data'] = parse_expr(stmt.data)\n"
	"                    ret['offset'] = stmt.offset\n"
	"                elif stmt.tag in [\"Ist_Store\"]:\n"
	"                    ret['data'] = parse_expr(stmt.data)\n"
	"                elif stmt.tag in [\"Ist_WrTmp\"]:\n"
	"                    ret['tmp'] = stmt.tmp\n"
	"                    ret['data'] = parse_expr(stmt.data)\n"
	"                elif stmt.tag == \"Ist_Exit\":\n"
	"                    ret['jumpkind'] = stmt.jumpkind\n"
	"                    ret['guard'] = parse_expr(stmt.guard)\n"
	"                    ret['offsIP'] = stmt.offsIP\n"
	"                    ret['dst'] = int(str(stmt.dst), 16)\n"
	"                elif stmt.tag == \"Ist_IMark\":\n"
	"                    ret['addr'] = stmt.addr\n"
	"                    ret['len'] = stmt.len\n"
	"                elif stmt.tag == \"Ist_AbiHint\":\n"
	"                    ret['base'] = parse_expr(stmt.base)\n"
	"                    ret['len'] = stmt.len\n"
	"                    ret['nia'] = int(str(stmt.nia), 16)\n"
	"                else:\n"
	"                    raise UnhandledStmtError(stmt)\n"
	"                print ret\n"
	"                insns.append(ret)\n"
	"    return insns\n"
	"\n"
	"if __name__ == '__main__':\n"
	"    if len(sys.argv) < 2:\n"
	"        usage()\n"
	"\n"
	"    BIN_FILE = sys.argv[1]\n"
	"    START_ADDR = 0x4000a5\n"
	"\n"
	"    with open(BIN_FILE, 'rb') as f:\n"
	"        insn_bytes = f.read()[0x25:]\n"
	"\n"
	"    insns = Lift(insn_bytes, START_ADDR, count)\n"
	"    # for x in insns:\n"
	"    #     print(x)\n" "";
