const char script[] = ""
	"#!/usr/bin/python2\n"
	"import pyvex\n"
	"import archinfo\n"
	"from capstone import *\n"
	"\n"
	"class UnhandledStmtError(Exception):\n"
	"    def __init__(self, x):\n"
	"        self.expression = x.pp()\n"
	"        self.message = \"Unhandled Statement Error\"\n"
	"\n"
	"def usage():\n"
	"    print(\"{} BIN_FILE\".format(sys.argv[0]))\n"
	"    exit(1)\n"
	"\n"
	"def clean_dir(x):\n"
	"    print(filter(lambda x: not x.startswith('_'), dir(x)))\n"
	"\n"
	"def parse_const(const):\n"
	"    ret = {}\n"
	"    ret['tag'] = const.tag\n"
	"    ret['size'] = const.size\n"
	"    ret['value'] = const.value\n"
	"    return ret\n"
	"\n"
	"def parse_expr_args(args, tyenv=None):\n"
	"    ret = []\n"
	"    for i, x in enumerate(args):\n"
	"        ret.append({})\n"
	"        ret[i]['tag'] = x.tag\n"
	"        if (tyenv is not None) and hasattr(x, \"result_size\"):\n"
	"            ret[i]['result_size'] = int(x.result_size(tyenv))\n"
	"        if x.tag in [\"Iex_RdTmp\"]:\n"
	"            ret[i]['tmp'] = x.tmp\n"
	"        elif x.tag in [\"Iex_Const\"]:\n"
	"            ret[i]['con'] = int(str(x.con), 16)\n"
	"        else:\n"
	"            raise UnhandledStmtError(expr)\n"
	"    return ret\n"
	"\n"
	"def parse_expr(expr, tyenv=None):\n"
	"    ret = {}\n"
	"    ret['tag'] = expr.tag\n"
	"    if (tyenv is not None) and hasattr(expr, \"result_size\"):\n"
	"        ret['result_size'] = int(expr.result_size(tyenv))\n"
	"    if hasattr(expr, \"endness\"):\n"
	"        ret['endness'] = expr.endness\n"
	"    if expr.tag in [\"Iex_Get\"]:\n"
	"        ret['offset'] = expr.offset\n"
	"        ret['ty'] = expr.ty\n"
	"    elif expr.tag in [\"Iex_Const\"]:\n"
	"        ret['con'] = int(str(expr.con), 16)\n"
	"    elif expr.tag in [\"Iex_RdTmp\"]:\n"
	"        ret['tmp'] = expr.tmp\n"
	"    elif expr.tag in [\"Iex_Binop\", \"Iex_Unop\"]:\n"
	"        ret['op'] = expr.op\n"
	"        ret['args'] = parse_expr_args(expr.args, tyenv=tyenv)\n"
	"        ret['nargs'] = len(ret['args'])\n"
	"    elif expr.tag in [\"Iex_Load\"]:\n"
	"        ret['addr'] = parse_expr(expr.addr, tyenv=tyenv)\n"
	"        ret['ty'] = expr.ty\n"
	"    elif expr.tag in [\"Iex_CCall\"]:\n"
	"        ret['retty'] = expr.retty\n"
	"        ret['cee'] = expr.cee\n"
	"        ret['args'] = parse_expr_args(expr.args, tyenv=tyenv)\n"
	"    else:\n"
	"        raise UnhandledStmtError(expr)\n"
	"    return ret\n"
	"\n"
	"def Lift(insn_bytes, START_ADDR, count):\n"
	"    try:\n"
	"        md = Cs(CS_ARCH_X86, CS_MODE_64)\n"
	"        # for i in md.disasm(insn_bytes, 0x1000):\n"
	"        #     print(\"0x%x:\\t%s\\t%s\" %(i.address, i.mnemonic, i.op_str))\n"
	"        #     print(\"%r\" % i.bytes)\n"
	"        #     irsb = pyvex.IRSB(bytes(i.bytes), START_ADDR, archinfo.ArchAMD64(), max_bytes=len(i.bytes))\n"
	"        #     irsb.pp()\n"
	"\n"
	"        offset = 0\n"
	"        len_insn_bytes = len(insn_bytes)\n"
	"        if count < len_insn_bytes:\n"
	"            len_insn_bytes = count\n"
	"            insn_bytes = insn_bytes[:len_insn_bytes]\n"
	"        insns = []\n"
	"        while offset < len_insn_bytes:\n"
	"            ### print a instruction\n"
	"            disasm_str = \"\"\n"
	"            for insn in md.disasm(insn_bytes[offset:], START_ADDR + offset):\n"
	"                # print(\"0x%x:\\t%s\\t%s\" %(insn.address, insn.mnemonic, insn.op_str))\n"
	"                disasm_str = \"%s\\t%s\" %(insn.mnemonic, insn.op_str)\n"
	"                # irsb = pyvex.IRSB(bytes(insn.bytes), insn.address, archinfo.ArchAMD64(), max_bytes=insn.size)\n"
	"                break\n"
	"            if True:\n"
	"                irsb = pyvex.IRSB(insn_bytes[offset:], insn.address, archinfo.ArchAMD64())\n"
	"\n"
	"                offset += irsb.size\n"
	"                # continue\n"
	"\n"
	"                ### pretty print a basic block\n"
	"                irsb.pp()\n"
	"\n"
	"                ### fetch block jumpkind\n"
	"                block_jump_insn = {}\n"
	"                if irsb.jumpkind:\n"
	"                    block_jump_insn['full'] = irsb.jumpkind.split('_', 1)[1]\n"
	"                    block_jump_insn['tag'] = \"Ist_Jump\"\n"
	"                    block_jump_insn['jumpkind'] = irsb.jumpkind\n"
	"\n"
	"                ### interpret statements\n"
	"                for stmt in irsb.statements:\n"
	"                    # clean_dir(stmt)\n"
	"                    # print(\"\")\n"
	"                    # stmt.pp()\n"
	"\n"
	"                    ret = {}\n"
	"                    ret['full'] = str(stmt)\n"
	"                    ret['tag'] = stmt.tag\n"
	"                    if False:\n"
	"                        pass\n"
	"                    elif stmt.tag in [\"Ist_Put\"]:\n"
	"                        ret['data'] = parse_expr(stmt.data, tyenv=irsb.tyenv)\n"
	"                        ret['offset'] = stmt.offset\n"
	"                    elif stmt.tag in [\"Ist_Store\"]:\n"
	"                        ret['addr_expr'] = parse_expr(stmt.addr) # <pyvex.expr.RdTmp object at 0x7f44c6c5ba70>\n"
	"                        ret['endness'] = stmt.endness\n"
	"                        ret['data'] = parse_expr(stmt.data, tyenv=irsb.tyenv)\n"
	"                    elif stmt.tag in [\"Ist_WrTmp\"]:\n"
	"                        ret['tmp'] = stmt.tmp\n"
	"                        ret['data'] = parse_expr(stmt.data, tyenv=irsb.tyenv)\n"
	"                    elif stmt.tag == \"Ist_Exit\":\n"
	"                        ret['jumpkind'] = stmt.jumpkind\n"
	"                        ret['guard'] = parse_expr(stmt.guard, tyenv=irsb.tyenv)\n"
	"                        ret['offsIP'] = stmt.offsIP\n"
	"                        ret['dst'] = parse_const(stmt.dst)\n"
	"                    elif stmt.tag == \"Ist_IMark\":\n"
	"                        ret['addr'] = stmt.addr\n"
	"                        ret['len'] = stmt.len\n"
	"                        ret['disasm'] = disasm_str\n"
	"                    elif stmt.tag == \"Ist_AbiHint\":\n"
	"                        ret['base'] = parse_expr(stmt.base, tyenv=irsb.tyenv)\n"
	"                        ret['len'] = stmt.len\n"
	"                        ret['nia'] = int(str(stmt.nia), 16)\n"
	"                    else:\n"
	"                        raise UnhandledStmtError(stmt)\n"
	"\n"
	"                    # print ret\n"
	"                    insns.append(ret)\n"
	"                if block_jump_insn is not {}:\n"
	"                    insns.append(block_jump_insn)\n"
	"                    pass\n"
	"\n"
	"    except Exception as e:\n"
	"        import sys, os\n"
	"        exc_type, exc_obj, exc_tb = sys.exc_info()\n"
	"        fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n"
	"        sys.stderr.write(\"[!] Exception: %s\\n\" % str((str(e), fname, exc_tb.tb_lineno)))\n"
	"\n"
	"    return insns\n"
	"\n"
	"if __name__ == '__main__':\n"
	"    try:\n"
	"        import sys\n"
	"        if len(sys.argv) < 2:\n"
	"            usage()\n"
	"\n"
	"        BIN_FILE = sys.argv[1]\n"
	"        START_ADDR = 0x4000a5\n"
	"\n"
	"        with open(BIN_FILE, 'rb') as f:\n"
	"            insn_bytes = f.read()[0x25:]\n"
	"\n"
	"        insns = Lift(insn_bytes, START_ADDR, len(insn_bytes))\n"
	"        for x in insns:\n"
	"            print(x)\n"
	"            pass\n"
	"    except Exception as e:\n"
	"        print(\"[!] Exception: \" + str(e))\n" "";
